<!DOCTYPE html>
<head>
    <meta charset="utf-8"/>
    <title>Sliding Puzzle Game</title>
    <script src="wasm_exec.js"></script>
    <style>
        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f7ff;
        }
        #app {
            background-color: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
        }
        h1 {
            color: #2196F3;
            font-size: 2.5em;
            margin-bottom: 20px;
        }
        .controls {
            margin: 20px 0;
        }
        button {
            background-color: #FF4081;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            margin: 10px;
            font-size: 1.2em;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            transition: transform 0.2s, background-color 0.2s;
        }
        button:hover {
            background-color: #E91E63;
            transform: scale(1.05);
        }
        select, input {
            padding: 10px;
            margin: 10px;
            border-radius: 15px;
            border: 2px solid #2196F3;
            font-size: 1.1em;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }
        .puzzle-grid {
            display: grid;
            gap: 10px;
            margin: 20px auto;
            max-width: 400px;
        }
        .puzzle-tile {
            background-color: #2196F3;
            color: white;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            aspect-ratio: 1;
            transition: transform 0.3s;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .puzzle-tile:hover {
            transform: scale(1.05);
        }
        .puzzle-tile.empty {
            background-color: #f0f7ff;
            border: 2px dashed #2196F3;
        }
        .solution-steps {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            background-color: #E3F2FD;
        }
        .step-counter {
            font-size: 1.2em;
            color: #1976D2;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>üß© Sliding Puzzle Game</h1>
        <div class="controls">
            <label for="size">Puzzle Size:</label>
            <input type="number" id="size" value="3" min="3" max="5">
            <button onclick="handleGenerate()">üé≤ New Puzzle</button>
        </div>
        <div class="controls">
            <label for="algorithm">Solve Using:</label>
            <select id="algorithm">
                <option value="astar">üåü A* Search</option>
                <option value="bfs">üå≥ Breadth First</option>
                <option value="dfs">üîç Depth First</option>
                <option value="ida">üîÑ Iterative Deepening</option>
                <option value="greedy">üèÉ Greedy Search</option>
            </select>
            <button onclick="handleSolve()">‚ú® Solve Puzzle</button>
        </div>
        <div id="result" style="display: none;"></div>
        <div id="puzzle-container"></div>
        <div id="solution-container" class="solution-steps"></div>
    </div>
    <script>
        const go = new Go();
        WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject)
            .then((result) => {
                go.run(result.instance);
            })
            .catch(error => {
                console.error('Error loading WebAssembly:', error);
            });

        function handleGenerate() {
            try {
                const size = parseInt(document.getElementById('size').value);
                generatePuzzle(size);
                
                // Get the puzzle data from the result div
                const resultDiv = document.getElementById('result');
                const puzzleData = JSON.parse(resultDiv.textContent);
                
                // Create the visual grid
                createPuzzleGrid(puzzleData.puzzle);
            } catch (error) {
                console.error('Error in handleGenerate:', error);
                alert('Error generating puzzle. Please try again.');
            }
        }

        function handleSolve() {
            try {
                const resultDiv = document.getElementById('result');
                if (!resultDiv || !resultDiv.textContent) {
                    alert('Please generate a puzzle first! üé≤');
                    return;
                }

                // Store the initial puzzle before solving
                const puzzleData = JSON.parse(resultDiv.textContent);
                window.initialPuzzleState = puzzleData.puzzle;  // Store initial state globally

                const algorithm = document.getElementById('algorithm').value;
                const request = {
                    board: puzzleData.puzzle,
                    algorithm: algorithm
                };

                solvePuzzle(JSON.stringify(request));
                
                // Parse the solution from the updated result div
                const solutionText = document.getElementById('result').textContent;
                const solutionData = JSON.parse(solutionText.replace(/<\/?pre>/g, ''));  // Remove pre tags
                displaySolution(solutionData);
            } catch (error) {
                console.error('Error in handleSolve:', error);
                alert('Error solving puzzle. Please try again.');
            }
        }

        function createPuzzleGrid(puzzleData) {
            // puzzleData is a 2D array of the puzzle
            // we need to convert it to a 1D array
            const flatPuzzleData = puzzleData.flat();
            const container = document.getElementById('puzzle-container');
            const size = flatPuzzleData.length;

            const grid = document.createElement('div');
            // size is the number of tiles in the puzzle
            // we need to convert it to the number of rows and columns  
            const linearSize = Math.sqrt(size);
            grid.className = 'puzzle-grid';
            grid.style.gridTemplateColumns = `repeat(${linearSize}, 1fr)`;
            
            flatPuzzleData.forEach((num) => {
                const tile = document.createElement('div');
                tile.className = `puzzle-tile ${num === 0 ? 'empty' : ''}`;
                tile.textContent = num === 0 ? '' : num;
                grid.appendChild(tile);
            });
            
            container.innerHTML = '';
            container.appendChild(grid);
        }

        function displaySolution(solution) {
            const container = document.getElementById('solution-container');
            if (!solution || !solution.solution) {
                container.innerHTML = '<p>No solution found!</p>';
                return;
            }
            
            // Store solution moves globally
            window.solutionMoves = solution.solution;
            
            container.innerHTML = `
                <h3>‚ú® Solution Found!</h3>
                <p class="step-counter">Number of moves: ${solution.solution.length}</p>
                <button onclick="startAnimation()">üé¨ Show Solution</button>
            `;
        }

        function startAnimation() {
            if (!window.initialPuzzleState || !window.solutionMoves) {
                console.error("Missing puzzle state or solution moves");
                return;
            }
            animateSolution(window.solutionMoves, window.initialPuzzleState);
        }

        function applyMove(puzzle, move) {
            // puzzleData is a 2D array of the puzzle
            // we need to convert it to a 1D array
            const flatPuzzleData = puzzle.flat();
            const size = Math.sqrt(flatPuzzleData.length);
            const newPuzzle = [...flatPuzzleData];
            
            // Find the empty tile (0)
            const emptyIndex = newPuzzle.indexOf(0);
            const row = Math.floor(emptyIndex / size);
            const col = emptyIndex % size;
            
            let swapIndex = -1;
            
            switch(move) {
                case "UP":
                    if (row < size - 1) swapIndex = emptyIndex + size;
                    break;
                case "DOWN":
                    if (row > 0) swapIndex = emptyIndex - size;
                    break;
                case "LEFT":
                    if (col < size - 1) swapIndex = emptyIndex + 1;
                    break;
                case "RIGHT":
                    if (col > 0) swapIndex = emptyIndex - 1;
                    break;
            }
            
            if (swapIndex !== -1) {
                // Swap the empty tile with the target tile
                [newPuzzle[emptyIndex], newPuzzle[swapIndex]] = [newPuzzle[swapIndex], newPuzzle[emptyIndex]];
            }
            
            return newPuzzle;
        }

        function animateSolution(moves, initialPuzzle) {
            console.log("Starting animation with:", { moves, initialPuzzle });
            let currentPuzzle = [...initialPuzzle];
            let currentMove = 0;
            
            // Show initial state
            createPuzzleGrid(currentPuzzle);
            
            const interval = setInterval(() => {
                if (currentMove >= moves.length) {
                    clearInterval(interval);
                    return;
                }
                
                console.log(`Applying move ${currentMove}: ${moves[currentMove]}`);
                currentPuzzle = applyMove(currentPuzzle, moves[currentMove]);
                createPuzzleGrid(currentPuzzle);
                
                currentMove++;
            }, 1000);
        }
    </script>
</body>
</html>
